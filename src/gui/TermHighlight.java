/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package gui;

import edu.stanford.nlp.ling.Sentence;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractButton;
import javax.swing.JCheckBox;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import utils.ReadUtils;

/**
 *
 * @author Administrator
 */
public class TermHighlight extends javax.swing.JFrame {

    /**
     * Creates new form TermHighlight
     */
    static Map code2Names=null;
    public TermHighlight(Vector sent,Map terms) {
        initComponents();
        code2Names=ReadUtils.readTxtFile("D:\\owl-extension\\ont-names.txt");
        this.detectOntology(sent,terms);
        //addChecjk();
        this.setVisible(true);
    }
    
    public TermHighlight(Vector originSent,Map originTerms,Vector plagSent,Map plagTerms) {
        initComponents();
        code2Names=ReadUtils.readTxtFile("D:\\owl-extension\\ont-names.txt");
        this.detectOriginPlagOntology(originSent,originTerms,plagSent,plagTerms);
        //addChecjk();
        this.setVisible(true);
    }
    
    public TermHighlight() throws BadLocationException {
        initComponents();
        //hiligthOntlogyTerms2(null, null, null, code2Names);
        this.setVisible(true);
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainSplitPane = new javax.swing.JSplitPane();
        originPanel = new javax.swing.JPanel();
        origniTxtOntologyPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        originTxtPaneDoc = new javax.swing.JTextPane();
        plagPanel = new javax.swing.JPanel();
        plagTxtOntologyPanel = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        plagTxtPaneDoc = new javax.swing.JTextPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        mainSplitPane.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        origniTxtOntologyPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        origniTxtOntologyPanel.setToolTipText("origin ontology panel");

        javax.swing.GroupLayout origniTxtOntologyPanelLayout = new javax.swing.GroupLayout(origniTxtOntologyPanel);
        origniTxtOntologyPanel.setLayout(origniTxtOntologyPanelLayout);
        origniTxtOntologyPanelLayout.setHorizontalGroup(
            origniTxtOntologyPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 796, Short.MAX_VALUE)
        );
        origniTxtOntologyPanelLayout.setVerticalGroup(
            origniTxtOntologyPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 35, Short.MAX_VALUE)
        );

        originTxtPaneDoc.setText("origin txt");
        jScrollPane1.setViewportView(originTxtPaneDoc);

        javax.swing.GroupLayout originPanelLayout = new javax.swing.GroupLayout(originPanel);
        originPanel.setLayout(originPanelLayout);
        originPanelLayout.setHorizontalGroup(
            originPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(originPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(origniTxtOntologyPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(originPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(originPanelLayout.createSequentialGroup()
                    .addContainerGap()
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 798, Short.MAX_VALUE)
                    .addContainerGap()))
        );
        originPanelLayout.setVerticalGroup(
            originPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(originPanelLayout.createSequentialGroup()
                .addComponent(origniTxtOntologyPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 209, Short.MAX_VALUE))
            .addGroup(originPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, originPanelLayout.createSequentialGroup()
                    .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 224, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap()))
        );

        mainSplitPane.setLeftComponent(originPanel);

        plagTxtOntologyPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        plagTxtOntologyPanel.setToolTipText("origin ontology panel");

        javax.swing.GroupLayout plagTxtOntologyPanelLayout = new javax.swing.GroupLayout(plagTxtOntologyPanel);
        plagTxtOntologyPanel.setLayout(plagTxtOntologyPanelLayout);
        plagTxtOntologyPanelLayout.setHorizontalGroup(
            plagTxtOntologyPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 796, Short.MAX_VALUE)
        );
        plagTxtOntologyPanelLayout.setVerticalGroup(
            plagTxtOntologyPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 35, Short.MAX_VALUE)
        );

        plagTxtPaneDoc.setText("plag  txt");
        jScrollPane2.setViewportView(plagTxtPaneDoc);

        javax.swing.GroupLayout plagPanelLayout = new javax.swing.GroupLayout(plagPanel);
        plagPanel.setLayout(plagPanelLayout);
        plagPanelLayout.setHorizontalGroup(
            plagPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(plagPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(plagPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(plagTxtOntologyPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 798, Short.MAX_VALUE))
                .addContainerGap())
        );
        plagPanelLayout.setVerticalGroup(
            plagPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(plagPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(plagTxtOntologyPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 224, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        mainSplitPane.setRightComponent(plagPanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mainSplitPane)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(mainSplitPane)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws BadLocationException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(TermHighlight.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(TermHighlight.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(TermHighlight.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(TermHighlight.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        //new TermHighlight().testMap();
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new TermHighlight().setVisible(true);
                } catch (BadLocationException ex) {
                    Logger.getLogger(TermHighlight.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }
    
    
    private void detectOntology(Vector str, Map terms) {
        Vector currentOnt=new Vector();
        origniTxtOntologyPanel.setLayout(new GridLayout(3, 3, 10, 10));

        //feed ontlogy panel
        Iterator ontologyItr = terms.keySet().iterator();
        while (ontologyItr.hasNext()) {
            String termName = (String) ontologyItr.next();
            Object termInfo = terms.get(termName);
            if (termInfo instanceof Map) {
                Map tempMap = (Map) termInfo;
                String termOntology = (String) tempMap.get("ontology");
                if (!currentOnt.contains(termOntology)) {
                    JCheckBox cb = new JCheckBox();
                    cb.setName(termOntology);
                    cb.setText((String)code2Names.get(termOntology));
                    ActionListener actionListener = new ActionListener(){
                        public void actionPerformed(ActionEvent actionEvent){
                            AbstractButton abstractButton = (AbstractButton) actionEvent.getSource();
                            String checkBoxName = abstractButton.getName();
                            String checkBoxText = abstractButton.getText();
                            hiligthOntlogyOriginTerms(checkBoxName, checkBoxText, str, terms);
                        }
                    };
                    cb.addActionListener(actionListener);
                    origniTxtOntologyPanel.add(cb);
                    origniTxtOntologyPanel.revalidate();
                    origniTxtOntologyPanel.repaint();
                    currentOnt.add(termOntology);
                }
            }
        }
        origniTxtOntologyPanel.repaint();
        origniTxtOntologyPanel.validate();

        this.repaint();
        this.validate();

        

    }
    private void hiligthOntlogyTerms(String checkBoxName, String checkBoxText, Vector sentences, Map terms) {

        StyledDocument doc = (StyledDocument) this.originTxtPaneDoc.getDocument();

        // Create a style object and then set the style attributes
        Style style = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(style, false);
        // Bold
        StyleConstants.setBold(style, false);
        // Font family
        StyleConstants.setFontFamily(style, "SansSerif");
        // Font size
        StyleConstants.setFontSize(style, 14);
        // Background color
        StyleConstants.setBackground(style, Color.WHITE);
        // Foreground color
        StyleConstants.setForeground(style, Color.black);

        //init new style
        Style interStyle = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(interStyle, false);
        // Bold
        StyleConstants.setBold(interStyle, false);
        // Font family
        StyleConstants.setFontFamily(interStyle, "SansSerif");
        // Font size
        StyleConstants.setFontSize(interStyle, 14);
        // Background color
        StyleConstants.setBackground(interStyle, Color.red);
        // Foreground color
        StyleConstants.setForeground(interStyle, Color.white);

        /*
        1- iter throw text sentences
        2- iter throw terms map
        3- get term name and ontology
        4- check if the term ontology is equal to checkBox name (ontology checkBox)
        5- if equal 4 print the contined sent with term hiligth
        */
        try {

            for (int i = 0; i < sentences.size(); i++) {
                //1-get one sentence
                String oneSent = (String) sentences.get(i);
                Iterator iter = terms.keySet().iterator();
                //2- iter throw terms map
                while (iter.hasNext()) {
                    //3- get term name and ontology
                    String termName = (String) iter.next();
                    Object termInfo = terms.get(termName);
                    if (termInfo instanceof Map) {
                        //get the term info map
                        Map tempMap = (Map) termInfo;
                        //get the term ontology
                        String termOntology = (String) tempMap.get("ontology");
                        //4- check if the term ontology is equal to checkBox name (ontology checkBox)
                        if (checkBoxName.equalsIgnoreCase(termOntology)) {
                            if (oneSent.contains(termName)){
                                //5- if sent contians term hiligth term
                                int termIndex = oneSent.indexOf(termName);
                                String subSent1 = oneSent.substring(0, termIndex);
                                int afterTermIndex = termName.length() + termIndex;
                                String subSent2 = oneSent.substring(afterTermIndex);
                                doc.insertString(doc.getLength(), subSent1, style);
                                doc.insertString(doc.getLength(), termName, interStyle);
                                doc.insertString(doc.getLength(), subSent2, style);
                                //doc.insertString(doc.getLength(), "\n", style);
                            }
                        }
                    }

                }
            }

        } catch (BadLocationException ex) {
            ex.toString();
        }
    }
    
    private void hiligthOntlogyPlagTerms(String ontologyCode, String ontologyName, Vector plagSent, Map plagTerms){

        this.plagTxtPaneDoc.setText("");
        StyledDocument doc = (StyledDocument) this.plagTxtPaneDoc.getDocument();

        // Create a style object and then set the style attributes
        Style style = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(style, false);
        // Bold
        StyleConstants.setBold(style, false);
        // Font family
        StyleConstants.setFontFamily(style, "SansSerif");
        // Font size
        StyleConstants.setFontSize(style, 14);
        // Background color
        StyleConstants.setBackground(style, Color.WHITE);
        // Foreground color
        StyleConstants.setForeground(style, Color.black);

        //init new style
        Style interStyle = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(interStyle, false);
        // Bold
        StyleConstants.setBold(interStyle, false);
        // Font family
        StyleConstants.setFontFamily(interStyle, "SansSerif");
        // Font size
        StyleConstants.setFontSize(interStyle, 14);
        // Background color
        StyleConstants.setBackground(interStyle, Color.red);
        // Foreground color
        StyleConstants.setForeground(interStyle, Color.white);
        
        //init new style
        Style multiInterStyle = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(multiInterStyle, false);
        // Bold
        StyleConstants.setBold(multiInterStyle, false);
        // Font family
        StyleConstants.setFontFamily(multiInterStyle, "SansSerif");
        // Font size
        StyleConstants.setFontSize(multiInterStyle, 14);
        // Background color
        StyleConstants.setBackground(multiInterStyle, Color.yellow);
        // Foreground color
        StyleConstants.setForeground(multiInterStyle, Color.white);

        
        /*
        1- building styles for ordinary text and style for terms
        2- sort terms by positions and burn them if there are tow terms in the same position will take the longer one
        3- detect the terms that belong to the same checkBox ontology
        4- print the sentence according to detected terms
        */
         List<Entry<Integer, String>> sortedTerms = burnAndOrderTermsForPrint(plagTerms);
         Map<Integer, String> detectedTerms = detectOntologyTerms(ontologyCode, sortedTerms, plagTerms);
         List<Entry<Integer, String>> sortedDetectedTerms=sortTerms(detectedTerms);
         try {
//        String prevToken="";
//        doc.insertString(doc.getLength(), " ", interStyle);
//        doc.insertString(doc.getLength(), oneToken, interStyle);
            int currentPos=0;
            int nexttermIndex=0;
            int currenttermIndex=0;
            Object[] termIndeces=sortedDetectedTerms.toArray();
            //Object[] termIndeces=detectedTerms.keySet().toArray();
             for (int i = 0; i < plagSent.size(); i++) {
                 //1-get one sentence
                 String oneSent = (String) plagSent.get(i);
                 //2-print sent with  included terms 
                 Map.Entry<Integer, String> entry=(Map.Entry<Integer, String>)termIndeces[0];
                 int termIndex=entry.getKey();
                 //print from the 0 to before first term index
                 String s0=oneSent.substring(0,termIndex);
                 System.out.println(s0);
                 doc.insertString(doc.getLength(),s0, style);
                 for (int j = 0; j < termIndeces.length; j++) {
                    //get the current and next term index
                    Map.Entry<Integer, String> currentEntry=(Map.Entry<Integer, String>)termIndeces[j];
                    currenttermIndex=currentEntry.getKey();
                    if(j+1<termIndeces.length){
                        Map.Entry<Integer, String> nextEntry=(Map.Entry<Integer, String>)termIndeces[j+1];
                        nexttermIndex=nextEntry.getKey();
                    }
                    else
                    {
                        nexttermIndex=oneSent.length();
                    }
                    //get the current term name to print it
                    String currentTerm=detectedTerms.get(currenttermIndex);
                    System.out.println(currentTerm);
                    
                    //print2- print the current term name
                    //test if the current term which will printed 
                    //test if is not a part for any prev term already printed
                    if((currenttermIndex+currentTerm.length())> currentPos ){
                    doc.insertString(doc.getLength(),currentTerm, interStyle);
                    }
                       
                    //increase the current position 
                    currentPos=currenttermIndex+currentTerm.length();
                    //print3-print the sub text between current term and next one
                    //print the sub string between the current term and the next one
                    //first test if the next concept is not contained in the current one
                     if (nexttermIndex > currentPos) {
                         String s1 = oneSent.substring(currentPos++, nexttermIndex);
                         System.out.println(s1);
                         doc.insertString(doc.getLength(), s1, style);
                     } else {
                        //j++; 
                        continue;
                     }
                 }
                //String lastS=oneSent.substring(currentPos,oneSent.length()); 
                //doc.insertString(doc.getLength(),lastS, style);
             }

         } catch (Exception ex) {
             ex.printStackTrace();
         }
        

    }

    
    
    private void hiligthOntlogyOriginTerms(String ontologyCode, String ontologyName, Vector originSent, Map originTerms){

        this.originTxtPaneDoc.setText("");
        StyledDocument doc = (StyledDocument) this.originTxtPaneDoc.getDocument();

        // Create a style object and then set the style attributes
        Style style = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(style, false);
        // Bold
        StyleConstants.setBold(style, false);
        // Font family
        StyleConstants.setFontFamily(style, "SansSerif");
        // Font size
        StyleConstants.setFontSize(style, 14);
        // Background color
        StyleConstants.setBackground(style, Color.WHITE);
        // Foreground color
        StyleConstants.setForeground(style, Color.black);

        //init new style
        Style interStyle = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(interStyle, false);
        // Bold
        StyleConstants.setBold(interStyle, false);
        // Font family
        StyleConstants.setFontFamily(interStyle, "SansSerif");
        // Font size
        StyleConstants.setFontSize(interStyle, 14);
        // Background color
        StyleConstants.setBackground(interStyle, Color.red);
        // Foreground color
        StyleConstants.setForeground(interStyle, Color.white);
        
        //init new style
        Style multiInterStyle = doc.addStyle("StyleName", null);
        // Italic
        StyleConstants.setItalic(multiInterStyle, false);
        // Bold
        StyleConstants.setBold(multiInterStyle, false);
        // Font family
        StyleConstants.setFontFamily(multiInterStyle, "SansSerif");
        // Font size
        StyleConstants.setFontSize(multiInterStyle, 14);
        // Background color
        StyleConstants.setBackground(multiInterStyle, Color.yellow);
        // Foreground color
        StyleConstants.setForeground(multiInterStyle, Color.white);

        
        /*
        1- building styles for ordinary text and style for terms
        2- sort terms by positions and burn them if there are tow terms in the same position will take the longer one
        3- detect the terms that belong to the same checkBox ontology
        4- print the sentence according to detected terms
        */
         List<Entry<Integer, String>> sortedTerms = burnAndOrderTermsForPrint(originTerms);
         Map<Integer, String> detectedTerms = detectOntologyTerms(ontologyCode, sortedTerms, originTerms);
         List<Entry<Integer, String>> sortedDetectedTerms=sortTerms(detectedTerms);
         try {
//        String prevToken="";
//        doc.insertString(doc.getLength(), " ", interStyle);
//        doc.insertString(doc.getLength(), oneToken, interStyle);
            int currentPos=0;
            int nexttermIndex=0;
            int currenttermIndex=0;
            Object[] termIndeces=sortedDetectedTerms.toArray();
            //Object[] termIndeces=detectedTerms.keySet().toArray();
             for (int i = 0; i < originSent.size(); i++) {
                 //1-get one sentence
                 String oneSent = (String) originSent.get(i);
                 //2-print sent with  included terms 
                 Map.Entry<Integer, String> entry=(Map.Entry<Integer, String>)termIndeces[0];
                 int termIndex=entry.getKey();
                 //print1- print part from the 0 to before first term index
                 String s0=oneSent.substring(0,termIndex);
                 System.out.println(s0);
                 doc.insertString(doc.getLength(),s0, style);
                 for (int j = 0; j < termIndeces.length; j++) {
                    //get the current and next term index
                    Map.Entry<Integer, String> currentEntry=(Map.Entry<Integer, String>)termIndeces[j];
                    currenttermIndex=currentEntry.getKey();
                    if(j+1<termIndeces.length){
                        Map.Entry<Integer, String> nextEntry=(Map.Entry<Integer, String>)termIndeces[j+1];
                        nexttermIndex=nextEntry.getKey();
                    }
                    else
                    {
                        nexttermIndex=oneSent.length();
                    }
                    //get the current term name to print it
                    String currentTerm=detectedTerms.get(currenttermIndex);
                    System.out.println(currentTerm);
                    
                    //print2- print the current term name
                    //test if the current term which will printed 
                    //test if is not a part for any prev term already printed
                    if((currenttermIndex+currentTerm.length())> currentPos ){
                    doc.insertString(doc.getLength(),currentTerm, interStyle);
                    }
                       
                    //increase the current position 
                    currentPos=currenttermIndex+currentTerm.length();
                    //print3-print the sub text between current term and next one
                    //print the sub string between the current term and the next one
                    //first test if the next concept is not contained in the current one
                     if (nexttermIndex > currentPos) {
                         String s1 = oneSent.substring(currentPos++, nexttermIndex);
                         System.out.println(s1);
                         doc.insertString(doc.getLength(), s1, style);
                     } else {
                        //j++; 
                        continue;
                     }
                 }
                //String lastS=oneSent.substring(currentPos,oneSent.length()); 
                //doc.insertString(doc.getLength(),lastS, style);
             }

         } catch (Exception ex) {
             ex.printStackTrace();
         }
        

    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane mainSplitPane;
    private javax.swing.JPanel originPanel;
    private javax.swing.JTextPane originTxtPaneDoc;
    private javax.swing.JPanel origniTxtOntologyPanel;
    private javax.swing.JPanel plagPanel;
    private javax.swing.JPanel plagTxtOntologyPanel;
    private javax.swing.JTextPane plagTxtPaneDoc;
    // End of variables declaration//GEN-END:variables

    

    private List<Entry<Integer, String>> burnAndOrderTermsForPrint(Map terms) {
        String termPosition;
        Integer intPos;
        
        Map <Integer, String> unsortTerms = new HashMap<Integer, String>();
        Iterator iter=terms.keySet().iterator();
        while(iter.hasNext()){
            String termName=(String)iter.next();
            Object termInfo=terms.get(termName);
            if (termInfo instanceof Map) 
            {
                Map mapTermInfo = (Map) termInfo;
                termPosition=mapTermInfo.get("position").toString();
                intPos=new Integer(termPosition);
                
            }
            else
            {
                termPosition=terms.get(termName).toString();
                intPos=new Integer(termPosition);
            }
            addAndUpdateMap(unsortTerms,intPos,termName);
            
            
           
        }
        
       // printMap(unsortTerms);
        List<Entry<Integer, String>> sortedMap=SortMapKeyAscending(unsortTerms);

	//printMap(sortedMap);
        return sortedMap;
    }
    
    private List<Entry<Integer, String>> sortTerms(Map terms) {
        // printMap(unsortTerms);
        List<Entry<Integer, String>> sortedMap=SortMapKeyAscending(terms);

	//printMap(sortedMap);
        return sortedMap;
    }
    
    public static void printMap(Map<Integer, String> map) {
		for (Map.Entry<Integer, String> entry : map.entrySet()) {
			System.out.println("Key : " + entry.getKey() 
                                      + " Value : " + entry.getValue());
		}
    }

    private void addAndUpdateMap(Map<Integer, String> unsortTerms, Integer intPos, String termName) {
        if(unsortTerms.keySet().contains(intPos)){
            String existName=unsortTerms.get(intPos);
            if(existName.contains(termName)){
                unsortTerms.replace(intPos, existName);
            }
            else
            {
                unsortTerms.replace(intPos, termName);
            }
        }else
            unsortTerms.put(intPos, termName);
    }

    private Map<Integer, String> detectOntologyTerms(String ontologyCode, List<Entry<Integer, String>> sortedTerms,Map terms) {
        
        
        Map<Integer, String> detectedOnto=new HashMap<Integer, String>();
        
        for(Map.Entry<Integer, String> entry:sortedTerms){
            
            int termPosition=(Integer)entry.getKey().intValue();
            String termName=entry.getValue().toString();
            Object infoObject=terms.get(termName);
            if(infoObject instanceof Map){
                Map infoMap=(Map)infoObject;
                String termOntology=infoMap.get("ontology").toString();
                if(termOntology.trim().equalsIgnoreCase(ontologyCode)){
                    detectedOnto.put(termPosition, termName);
                }
            }
        }
        return detectedOnto;
    }

    private void detectOriginPlagOntology(Vector originSent, Map originTerms, Vector plagSent, Map plagTerms) {
        /*feel the origin term ontology and add checkbox for every 
        ontology and make the action performed when the check in checked
        which will color the terms that belongs to the checked ontology
        */
        Vector currentOriginOnt=new Vector();
        origniTxtOntologyPanel.setLayout(new GridLayout(3, 3, 10, 10));

        //feed ontlogy panel
        Iterator ontologyItr = originTerms.keySet().iterator();
        while (ontologyItr.hasNext()){
            String originTermName = (String) ontologyItr.next();
            Object originTermInfo = originTerms.get(originTermName);
            if (originTermInfo instanceof Map) {
                Map tempMap = (Map) originTermInfo;
                String originTermOntology = (String) tempMap.get("ontology");
                if (!currentOriginOnt.contains(originTermOntology)) {
                    JCheckBox originOntologyCheckBox = new JCheckBox();
                    originOntologyCheckBox.setName(originTermOntology);
                    originOntologyCheckBox.setText((String)code2Names.get(originTermOntology));
                    ActionListener actionListener = new ActionListener(){
                        public void actionPerformed(ActionEvent actionEvent){
                            AbstractButton abstractButton = (AbstractButton) actionEvent.getSource();
                            String ontologyCode = abstractButton.getName();
                            String ontologyName = abstractButton.getText();
                            hiligthOntlogyOriginTerms(ontologyCode, ontologyName, originSent, originTerms);
                        }
                    };
                    originOntologyCheckBox.addActionListener(actionListener);
                    origniTxtOntologyPanel.add(originOntologyCheckBox);
                    origniTxtOntologyPanel.revalidate();
                    origniTxtOntologyPanel.repaint();
                    currentOriginOnt.add(originTermOntology);
                }
            }
        }
        origniTxtOntologyPanel.repaint();
        origniTxtOntologyPanel.validate();

        this.repaint();
        this.validate(); 
        
        /*feel the plag term ontology and add checkbox for every 
        ontology and make the action performed when the check in checked
        which will color the terms that belongs to the checked ontology
        */
        Vector currentPlagOnt=new Vector();
        plagTxtOntologyPanel.setLayout(new GridLayout(3, 3, 10, 10));

        //feed ontlogy panel
        Iterator plagOntologyItr = plagTerms.keySet().iterator();
        while (plagOntologyItr.hasNext()) {
            String plagTermName = (String) plagOntologyItr.next();
            Object plagTermInfo = plagTerms.get(plagTermName);
            if (plagTermInfo instanceof Map) {
                Map tempMap = (Map) plagTermInfo;
                String plagTermOntology = (String) tempMap.get("ontology");
                if (!currentPlagOnt.contains(plagTermOntology)) {
                    JCheckBox plagOntologyCheckBox = new JCheckBox();
                    plagOntologyCheckBox.setName(plagTermOntology);
                    plagOntologyCheckBox.setText((String)code2Names.get(plagTermOntology));
                    ActionListener actionListener = new ActionListener(){
                        public void actionPerformed(ActionEvent actionEvent){
                            AbstractButton abstractButton = (AbstractButton) actionEvent.getSource();
                            String ontologyCode = abstractButton.getName();
                            String ontologyName = abstractButton.getText();
                            hiligthOntlogyPlagTerms(ontologyCode, ontologyName, plagSent, plagTerms);
                        }
                    };
                    plagOntologyCheckBox.addActionListener(actionListener);
                    plagTxtOntologyPanel.add(plagOntologyCheckBox);
                    plagTxtOntologyPanel.revalidate();
                    plagTxtOntologyPanel.repaint();
                    currentPlagOnt.add(plagTermOntology);
                }
            }
        }
        plagTxtOntologyPanel.repaint();
        plagTxtOntologyPanel.validate();

        this.repaint();
        this.validate(); 
        
        
    }
    
    
    class SortByKeyAscending implements Comparator<Map.Entry<Integer, String>>{

        @Override
        public int compare( Map.Entry<Integer,String> entry1, Map.Entry<Integer,String> entry2){
            return (entry1.getKey()).compareTo( entry2.getKey() );
        }
    }
    
     public  List<Entry<Integer, String>>   SortMapKeyAscending(Map<Integer, String> map){
       
        Map<Integer, String> sortedMap= new HashMap<Integer, String>();
        Set<Entry<Integer, String>> entrySet = map.entrySet();
        List<Entry<Integer, String>> listOfentrySet = new ArrayList<Entry<Integer, String>>(entrySet);
   
        System.out.print("Before sorting by key : ");
        for(Map.Entry<Integer, String> entry:listOfentrySet){
         System.out.print(entry.getKey()+"="+entry.getValue()+"  ");
        }
       
        Collections.sort(listOfentrySet, new SortByKeyAscending());
       
 
        System.out.print("\nAfter sorting by key(ascending): ");
        for(Map.Entry<Integer, String> entry:listOfentrySet){
            sortedMap.put(entry.getKey(), entry.getValue());
            System.out.print(entry.getKey()+"="+entry.getValue()+"  ");
        }
       
       return listOfentrySet;
    }
}
